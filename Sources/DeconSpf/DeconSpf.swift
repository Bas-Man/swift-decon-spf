// Copyright 2021 Adam Spann
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// swift-tools-version:5.3
// The swift-tools-version declares the minimum version of Swift required to build this
// package.

import Foundation
import Network

//CONSTANTS
internal let aRegex = #"^([+?~-])?a([:/]{0,1}.*)?"#
internal let MxRegex = #"^([+?~-])?mx([:/]{0,1}.*)?"#

/**
 This is a struct which represents an SPF record as found in and DNS Record.
 */
public struct SPF {
    private(set) var source: String
    var version: String = ""
    var fromSource = false
    var redirect: Mechanism?
    var is_redirect: Bool = false
    var include: [Mechanism]?
    var a: [Mechanism]?
    var mx: [Mechanism]?
    var ip4: [Mechanism]?
    var ip6: [Mechanism]?
    var all: Mechanism?
    
    /**
     Initialises an empty SPF struct.
     
     Using this empty struct we can build an SPF record using the `add` methods that SPF provides.
     
     # Example
     ```
        var spf = SPF()
        spf.addVersion("v=spf1")
        spf.addA(q: Qualifier.Pass)
        spf.addAll(q: Qualififer.Pass)
        spf.validate()
        spf.asSPF()
     ```
     
     */
    public init() {
        self.source = ""
        self.fromSource = false
    }
    /**
     Initialises the SPF struct
     - parameter source: The string passed from an exist TXT DNS record.
     */
    public init(source: String) {
        self.source = source
        self.fromSource = true
    }
    /**
        - returns:
            - The original string used to create the SPF struct. If SPF is created using `SPF(source:)`
            - The SPF recorded generated by `validate()` if successful.
     */
    public func getSource() -> String {
        self.source
    }
    /**
     - returns: True if the spf record is a redirect to another spf record.
     */
    public func isRedirect() -> Bool {
        self.is_redirect
    }
    /**
     - returns: True if the spf records starts with "v="
     */
    public func isV1() -> Bool {
        self.version.starts(with: "v=")
     }
    /**
     - returns: True if the spf recard starts with "spf2"
     */
    public func isV2() -> Bool {
        self.version.starts(with: "spf2")
    }
    /**
     Checks that the spf record is valid
     
     This function will check that the array of includes does not exceed 10. It also check that the total length of the spf string does not exceed 255 characters
     
     - returns: True if the number include items are equal or less than 10 and the overall string length is 255 chraacters or less.
     */
    public func isValid() -> Bool {
        if self.include?.count ?? 0 > 10 {
            return false
        }
        if (self.source.count > 255) || self.source == "" {
            return false
        }
        return true
    }
    /**
     This function processes self.source and populates the spf struct.
     
     As part of this process it creates all required Mechanism structs that are present in the spf string.
     */
    public mutating func parse() {
        
        let splitString = self.source.split(separator: " ")
        // Arrays for holding Mechanisms that are found.
        var includeData: [Mechanism] = []
        var aData: [Mechanism] = []
        var mxData: [Mechanism] = []
        var ip4Data: [Mechanism] = []
        var ip6Data: [Mechanism] = []
       
        for subString in splitString {
            //Done
            if (subString.starts(with: "v=") || subString.starts(with: "spf2")) {
                self.version = String(subString)
            }
            // Done
            else if (subString.range(of: "redirect=") != nil) {
                let qualifierMechanism = subString.split(separator: "=")
                self.redirect = Mechanism(k: MechanismKind.Redirect,
                                          q: identifyQualifier(prefix: qualifierMechanism[0]),
                                          m: String(qualifierMechanism[1]))
                self.is_redirect = true
            }
            // Done
            else if (subString.range(of: "include:") != nil) {
                let qualifierMechanism = subString.split(separator: ":")
                includeData.append(
                    Mechanism(k: MechanismKind.Include,
                              q: identifyQualifier(
                                    prefix: qualifierMechanism[0]),
                                    m: String(qualifierMechanism[1]
                                 )
                    )
                )
            }
            // Done
            else if (subString.range(of: "ip4:") != nil) {
                ip4Data.append(
                    processIp(subString: subString,
                              kind: MechanismKind.Ip4)
                )
            }
            // Done
            else if (subString.range(of: "ip6:") != nil) {
                ip6Data.append(
                    processIp(subString: subString,
                              kind: MechanismKind.Ip6)
                )
            }
            // Checking that the string ends with "all"
            else if (subString.hasSuffix("all")) {
                self.all = Mechanism(k: MechanismKind.All,
                                     q: identifyQualifier(prefix: subString))
            }
            // aMechanism is only appended if aMechanism is not nil
            else if let aMechanism =
                    String(subString).matchMechanism(regex: aRegex,
                                                     kind: MechanismKind.A) {
                    aData.append(aMechanism)
                }
            // mxMechanism is only appended if mxMechanism is not nil
            else if let mxMechanism =
                String(subString).matchMechanism(regex: MxRegex,
                                                 kind: MechanismKind.MX) {
                    mxData.append(mxMechanism)
                }
        }
        // If any Mechanisms have been found. Assign their array to the relevent
        // variable in struct spf.
        if !includeData.isEmpty {
            self.include = includeData
        }
        if !aData.isEmpty {
            self.a = aData
        }
        if !mxData.isEmpty {
            self.mx = mxData
        }
        if !ip4Data.isEmpty {
            self.ip4 = ip4Data
        }
        if !ip6Data.isEmpty {
            self.ip6 = ip6Data
        }
    }
    /**
     This function will attempt to recreate the original spf record.
     
     - note: This function processes the struct in the following order:
        - redirect
        - a
        - mx
        - include
        - ip4
        - ip6
        - all
        
        If your original order differs from this. The items should match, but the order will differ.
     */
    public func asSpf() -> String {
        var spf = String()
        //if self.isValid() {
            spf += self.version
            if self.isRedirect() {
                spf += " " + (self.redirect?.asMechanism())!
            }
  //          else {
                if self.a != nil {
                    for mechanism in self.a! {
                        spf += " " + mechanism.asMechanism()
                    }
                }
                if self.mx != nil {
                    for mechanism in self.mx! {
                        spf += " " + mechanism.asMechanism()
                    }
                }
                if self.include != nil {
                    for mechanism in self.include! {
                        spf += " " + mechanism.asMechanism()
                    }
                }
                if self.ip4 != nil {
                    for mechanism in self.ip4! {
                        spf += " " + mechanism.asMechanism()
                    }
                }
                if self.ip6 != nil {
                    for mechanism in self.ip6! {
                        spf += " " + mechanism.asMechanism()
                    }
                }
  //          }
            if self.all != nil {
                spf += " " + self.all!.asMechanism()
            }
    //    }
        return spf
    }
    /**
     Generic function to add a version string to the SPF struct.
     */
    public mutating func addVersion(version: String) {
        self.version = version
    }
    /**
     Make the SPF struct represent a spf record conforming to Version 1.
     */
    public mutating func makeV1() {
        self.version = "v=spf1"
    }
    /**
     Add a `Redirect` mechanism using the string provided.
          
     # Example:
     
     ```
     var spf = SPF()
     spf.makeV1()
     spf.addRedirect(fromStr: "_spf.example.com")
     ```
     
     - parameter fromStr: The string to be used in the `redirect=` mechanism.
     
     */
    public mutating func addRedirect(fromStr: String) {
        self.redirect = Mechanism(k: MechanismKind.Redirect,
                                  q: Qualifier.None,
                                  m: fromStr)
        self.is_redirect = true
    }
    /**
     This does the same work as `addRedirect(fromStr:)` but takes an already existing `Mechanism` of `MechanismKind.Redirect`
     */
    public mutating func addRedirect(mechanism: Mechanism) {
        self.redirect = mechanism
        self.is_redirect = true
    }
    public mutating func addA(q: Qualifier) {
        let mechanism = Mechanism(k: MechanismKind.A,
                                  q: q)
        if self.a == nil {
            self.a = []
        }
        self.a?.append(mechanism)
    }
    public mutating func addA(q: Qualifier, fromStr: String) {
        let mechanism = Mechanism(k: MechanismKind.A,
                                  q: q,
                                  m: fromStr)
        if self.a == nil {
            self.a = []
        }
        self.a?.append(mechanism)
    }
    public mutating func addA(mechanism: Mechanism) {
        if mechanism.whatKind() != MechanismKind.A {
            return
        }
        if self.a == nil {
            self.a = []
        }
        self.a?.append(mechanism)
    }
    public mutating func addMx(q: Qualifier) {
        let mechanism = Mechanism(k: MechanismKind.MX, q: q)
        if self.mx == nil {
            self.mx = []
        }
        self.mx?.append(mechanism)
    }
    public mutating func addMx(q: Qualifier, fromStr: String) {
        let mechanism = Mechanism(k: MechanismKind.MX,
                                  q: q,
                                  m: fromStr)
        if self.mx == nil {
            self.mx = []
        }
        self.mx?.append(mechanism)
    }
    public mutating func addMx(mechanism: Mechanism) {
        if mechanism.whatKind() != MechanismKind.MX {
            // This is not the correct MechanismKind. Go no further
            return
        }
        if self.mx == nil {
            self.mx = []
        }
        self.mx?.append(mechanism)

    }
    public mutating func addInclude(q: Qualifier, fromStr: String) {
        let mechanism = Mechanism(k: MechanismKind.Include,
                                  q: q,
                                  m: fromStr)
        if self.include == nil {
            self.include = []
        }
        self.include?.append(mechanism)
    }
    public mutating func addInclude(mechanism: Mechanism) {
        if mechanism.whatKind() != MechanismKind.Include {
            // This is not the correct MechanismKind. Go no further
            return
        }
        if self.include == nil {
            self.include = []
        }
        self.include?.append(mechanism)
    }
    public mutating func addIp4(q: Qualifier, fromStr: String) {
        let mechanism = Mechanism(k: MechanismKind.Ip4,
                                  q: q,
                                  m: fromStr)
        if self.ip4 == nil {
            self.ip4 = []
        }
        self.ip4?.append(mechanism)
    }
    public mutating func addIp4(mechanism: Mechanism) {
        if mechanism.whatKind() != MechanismKind.Ip4 {
            // This is not the correct MechanismKind. Go no further
            return
        }
        if self.ip4 == nil {
            self.ip4 = []
        }
        self.ip4?.append(mechanism)
    }
    public mutating func addIp6(q: Qualifier, fromStr: String) {
        let mechanism = Mechanism(k: MechanismKind.Ip6,
                                  q: q,
                                  m: fromStr)
        if self.ip6 == nil {
            self.ip6 = []
        }
        self.ip6?.append(mechanism)

    }
    public mutating func addIp6(mechanism: Mechanism) {
        if mechanism.whatKind() != MechanismKind.Ip6 {
            // This is not the correct MechanismKind. Go no further
            return
        }
        if self.ip6 == nil {
            self.ip6 = []
        }
        self.ip6?.append(mechanism)

    }
    public mutating func addAll(q: Qualifier) {
        self.all = Mechanism(k: MechanismKind.All, q: q)
    }
    public mutating func addAll(mechanism: Mechanism) {
        self.all = mechanism
    }
    public mutating func validate() -> Bool {
        if self.fromSource == true {
            return self.isValid()
        }
        if (self.version != "v=spf1") && (!self.version.starts(with: "spf2.0")) {
            return false
        }
        if self.include?.count ?? 0 > 10 {
            return false
        } else {
            let spf = self.asSpf()
            if spf.count > 255 {
                return false
            } else {
                self.source = spf
            }
        }
        return true
    }
}

private func identifyQualifier<S: StringProtocol>(prefix s: S)  -> Qualifier {
    let char = String(s.prefix(1))
    let c = Character(char)
    if !c.isLetter {
        switch char {
        case "+":
            return Qualifier.Pass
        case "-":
            return Qualifier.Fail
        case "~":
            return Qualifier.SoftFail
        case "?":
            return Qualifier.Neutral
        default:
            return Qualifier.None
        }
    }
    return Qualifier.None
}

private func processIp<S: StringProtocol>(subString s: S, kind: MechanismKind) -> Mechanism {
    let qualifierMechanism = s.split(separator: ":", maxSplits: 1, omittingEmptySubsequences: true)
    let qualifier = identifyQualifier(prefix: qualifierMechanism[0])
    return Mechanism(k: kind, q: qualifier, m: String(qualifierMechanism[1]))
    
}

extension String {
    /**
     Creates a Mechanism if the regular expression finds a match.
     
     - parameters:
        - regex: The regular expression string to be used.
        - kind: The MechanismKind to be created.

     - returns: A Mechanism of the kind specified if there is a match, else returns nil
     
     */
    func matchMechanism(regex: String, kind: MechanismKind) -> Mechanism? {
        
        let capturePattern = regex
        // Array to store matched substrings, used to create a new Mechanism
        var elements: [String] = []
        
        // Get the range of the string
        let stringRange = NSRange(
            self.startIndex..<self.endIndex,
            in: self
        )

        let captureRegex = try! NSRegularExpression(
            pattern: capturePattern,
            options: .caseInsensitive
        )
        let matches = captureRegex.matches(in: self, options: [], range: NSRange(location: 0, length: (self as NSString).length))

        // We didn't find a match. Return nil
        guard let match = matches.first else { return nil  }

        // For each matched range, extract the capture group
        for rangeIndex in 0..<match.numberOfRanges {
            let matchRange = match.range(at: rangeIndex)
            
            // Ignore matching the entire username string
            if matchRange == stringRange { continue }
            
            // Extract the substring matching the capture group
            if let substringRange = Range(matchRange, in: self) {
                let capture = String(self[substringRange])
                elements.append(capture)
            
            }
        }
        // If count is less than 2 there was no Qualifier
        var q = Qualifier.None
        // Qualifer will always be in the first capture if present.
        if elements.count == 2 {
            q = identifyQualifier(prefix: elements.first!)
        }
        // There will always be a capture which contain the IP Address string.
        return Mechanism(k: kind, q: q, m: elements.last!)
    }
    /**
     - Not Implemented!
     */
    func validIp4() -> Bool {
        let ip_cidr = self.split(separator: "/", maxSplits: 1, omittingEmptySubsequences: true)
        if #available(OSX 10.14, *) {
            if IPv4Address(String(ip_cidr[0])) != nil {
                return true
            }
        } else {
            // Fallback on earlier versions
        }

        return false
    }
    /**
     - Not Implemented!
     */
    func validIp6() -> Bool {
        let ip_cidr = self.split(separator: "/", maxSplits: 1, omittingEmptySubsequences: true)
        if #available(OSX 10.14, *) {
            if IPv6Address(String(ip_cidr[0])) != nil {
                return true
            }
        } else {
            // Fallback on earlier versions
        }
        return false
    }

}
